(function(){"use strict";let o,a=0,c=!1,k=!1,i=[],h=!1;const S=30;let W=null,m=[];async function M(t){if(console.log("[Worker] Initializing with WASM URL:",t),!t)throw new Error("WASM URL not provided");const e=await import(t);console.log("[Worker] Module factory loaded.");const r={print:n=>console.log("[WASM Print]",n),printErr:n=>console.error("[WASM Error]",n),locateFile:n=>(console.log("[Worker] Locating file:",n),t.replace("lux.js",n)),importMemory:!0};try{o=await e.default(r),console.log("[Worker] Module instance created.")}catch(n){throw console.error("[Worker] Failed to initialize module:",n),new Error(`Module initialization failed: ${n.message}`)}const s=Object.keys(o).filter(n=>typeof o[n]=="function");console.log("[Worker] Module exports:",s);const g=["start_recording","stop_recording","get_recording_data","get_recorded_frame_count","get_recording_state","get_recording_error","is_recording","worker_add_frame"].filter(n=>!(o&&typeof o[n]=="function"));if(g.length===0)console.log("[Worker] Critical recording functions verified.");else throw console.error(`[Worker] Missing required recording functions: [${g.join(", ")}]`),new Error(`Module recording functions missing: ${g.join(", ")}`)}function F(){if(o&&typeof o.get_recording_error=="function")try{return o.get_recording_error()}catch(t){return console.error("[Worker Helper] Failed to get C++ error:",t),"Failed to get C++ error: "+(t.message||t)}return"Module or get_recording_error not available"}async function _(){if(console.log("[Worker] === PROCESS FRAME QUEUE START ==="),console.log("[Worker] isProcessingFrames:",h),console.log("[Worker] frameQueue.length:",i.length),console.log("[Worker] recordingInProgress:",c),h||i.length===0){console.log("[Worker] Skipping frame processing - already processing or empty queue");return}h=!0;const t=5;console.log("[Worker] Starting frame processing with batch size:",t);try{for(;i.length>0&&c;){const e=i.splice(0,t);console.log("[Worker] Processing batch of",e.length,"frames. Remaining in queue:",i.length);for(const r of e){const s=performance.now();try{if(console.log(`[Worker] === PROCESSING FRAME ${a+1} ===`),console.log(`[Worker] Frame dimensions: ${r.width}x${r.height}`),console.log("[Worker] Frame imageData type:",r.imageData.constructor.name),console.log("[Worker] Frame imageData length:",r.imageData.length),console.log("[Worker] Expected length:",r.width*r.height*4),console.log(`[Worker] Queue remaining: ${i.length}, recording: ${c}`),!o||typeof o.worker_add_frame!="function"){console.error("[Worker] CppModule or worker_add_frame not available"),console.error("[Worker] - CppModule:",!!o),console.error("[Worker] - worker_add_frame type:",typeof(o&&o.worker_add_frame));continue}if(!r.imageData||!r.width||!r.height){console.error("[Worker] Invalid frame data:",{hasImageData:!!r.imageData,width:r.width,height:r.height});continue}console.log("[Worker] Calling CppModule.worker_add_frame...");const l=o.worker_add_frame(r.imageData,r.width,r.height);console.log("[Worker] worker_add_frame returned:",l);const n=performance.now()-s;if(m.push(n),l){if(a++,console.log(`[Worker] ✓ Frame ${a} added successfully in ${n.toFixed(2)}ms`),a%10===0){const f=m.reduce((p,y)=>p+y,0)/m.length,u=(performance.now()-W)/1e3,w=a/u;console.log(`[Worker] Performance metrics:
                                Frame #${a}
                                Queue size: ${i.length}
                                Avg processing time: ${f.toFixed(2)}ms
                                Total duration: ${u.toFixed(2)}s
                                Actual FPS: ${w.toFixed(2)}
                                Target FPS: 30`),self.postMessage({type:"recordingProgress",frameCount:a,metrics:{avgProcessingTime:f,totalDuration:u,actualFps:w,queueSize:i.length}}),m=[]}}else{if(console.error(`[Worker] ✗ Failed to add frame ${a+1} - C++ function returned false`),typeof o.get_recording_error=="function"){const f=o.get_recording_error();console.error(`[Worker] C++ error: ${f}`)}if(typeof o.get_recording_state=="function"){const f=o.get_recording_state();console.error(`[Worker] Recording state: ${f}`)}if(typeof o.is_recording=="function"){const f=o.is_recording();console.error(`[Worker] C++ is_recording: ${f}`)}}}catch(l){console.error(`[Worker] ✗ Exception adding frame ${a+1}:`,l),console.error("[Worker] Frame data:",{hasImageData:!!r.imageData,imageDataLength:r.imageData?r.imageData.length:0,width:r.width,height:r.height,expectedLength:r.width*r.height*4})}}await new Promise(r=>setTimeout(r,0))}}finally{h=!1,console.log("[Worker] === PROCESS FRAME QUEUE END ==="),console.log("[Worker] Final queue size:",i.length),console.log("[Worker] Total frames processed:",a)}}self.onmessage=async t=>{const e=t.data;console.log("[Worker] Received message:",e.type);try{switch(e.type){case"init":if(k){console.log("[Worker] Already initialized");return}console.log("[Worker] Initializing..."),await M(e.wasmUrl),k=!0,self.postMessage({type:"initialized"});break;case"startRecording":if(console.log("[Worker] === START RECORDING REQUEST ==="),console.log("[Worker] isInitialized:",k),console.log("[Worker] recordingInProgress:",c),!k)throw console.error("[Worker] ERROR: Worker not initialized"),new Error("Worker not initialized");c&&(console.log("[Worker] Already recording, stopping first"),await E()),console.log("[Worker] Starting H.264/MP4 recording with options:",e.options),console.log("[Worker] Original options dimensions:",e.options.width,"x",e.options.height),c=!0,a=0,W=performance.now(),m=[],console.log("[Worker] Using adaptive canvas dimensions for recording...");let r=e.options.width,s=e.options.height;r%2!==0&&(r=r-1,console.log(`[Worker] Adjusted width to even number: ${r}`)),s%2!==0&&(s=s-1,console.log(`[Worker] Adjusted height to even number: ${s}`));const l=1920,g=16;if((r>l||s>l)&&console.warn(`[Worker] WARNING: Large dimensions (${r}x${s}) may cause issues on mobile devices`),r<g||s<g){console.error(`[Worker] ERROR: Dimensions too small (${r}x${s}), minimum is ${g}x${g}`),c=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Dimensions too small for H.264 encoding"});return}console.log(`[Worker] Final recording dimensions: ${r}x${s}`),console.log(`[Worker] Original canvas dimensions: ${e.options.width}x${e.options.height}`);const n=o.get_buf_width(),f=o.get_buf_height();console.log(`[Worker] Buffer dimensions (for reference): ${n}x${f}`),console.log("[Worker] Calling C++ start_recording with CANVAS dimensions:"),console.log("[Worker] - Width:",r),console.log("[Worker] - Height:",s),console.log("[Worker] - FPS:",e.options.fps),console.log("[Worker] - Bitrate:",e.options.bitrate),console.log("[Worker] - Codec:",e.options.codec),console.log("[Worker] - Format:",e.options.format),console.log("[Worker] - Preset:",e.options.preset);const u=await o.start_recording(r,s,e.options.fps,e.options.bitrate,e.options.codec,e.options.format,e.options.preset);if(console.log("[Worker] start_recording returned:",u),u){if(console.log("[Worker] ✓ Recording started successfully"),typeof o.get_recording_state=="function"){const d=o.get_recording_state();console.log("[Worker] C++ recording state after start:",d)}if(typeof o.is_recording=="function"){const d=o.is_recording();console.log("[Worker] C++ is_recording after start:",d)}self.postMessage({type:"recordingStarted",success:!0})}else{if(console.error("[Worker] ✗ Failed to start H.264 recording"),typeof o.get_recording_error=="function"){const d=o.get_recording_error();console.error("[Worker] C++ error:",d)}c=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Failed to start H.264 recording"})}break;case"addFrame":if(console.log("[Worker] === ADD FRAME REQUEST ==="),console.log("[Worker] CppModule available:",!!o),console.log("[Worker] worker_add_frame available:",!!(o&&o.worker_add_frame)),console.log("[Worker] recordingInProgress:",c),!o||!o.worker_add_frame||!c){console.warn("[Worker] Ignoring frame - not ready or not recording"),console.warn("[Worker] - CppModule:",!!o),console.warn("[Worker] - worker_add_frame:",!!(o&&o.worker_add_frame)),console.warn("[Worker] - recordingInProgress:",c);return}if(console.log("[Worker] Frame data validation:"),console.log("[Worker] - hasImageData:",!!e.imageData),console.log("[Worker] - width:",e.width),console.log("[Worker] - height:",e.height),console.log("[Worker] - imageData type:",e.imageData?e.imageData.constructor.name:"null"),console.log("[Worker] - imageData length:",e.imageData?e.imageData.length:0),console.log("[Worker] - expected length:",e.width*e.height*4),!e.imageData||!e.width||!e.height){console.error("[Worker] Invalid frame data:",{hasImageData:!!e.imageData,width:e.width,height:e.height});return}if(typeof o.get_recording_state=="function"){const d=o.get_recording_state();console.log("[Worker] Current C++ recording state:",d)}if(typeof o.is_recording=="function"){const d=o.is_recording();console.log("[Worker] C++ is_recording:",d)}console.log("[Worker] Adding frame to queue. Current queue size:",i.length),i.push({imageData:e.imageData,width:e.width,height:e.height}),console.log("[Worker] Frame added to queue. New queue size:",i.length),i.length>=S&&(console.log("[Worker] Queue size reached MAX_QUEUE_SIZE, processing frames"),_());break;case"stopRecording":if(!c){console.log("[Worker] Not recording");return}const p=(performance.now()-W)/1e3;console.log(`[Worker] Recording stopped after ${p.toFixed(2)}s with ${a} frames`),console.log(`[Worker] Average FPS: ${(a/p).toFixed(2)}`),c=!1,i.length>0&&await _();const y=await E();self.postMessage({...y,metrics:{totalDuration:p,totalFrames:a,averageFps:a/p}});break;case"getState":if(!o){self.postMessage({type:"recorderState",state:"module_not_ready",frameCount:0,queueSize:0});return}try{const d=typeof o.get_recording_state=="function"?o.get_recording_state():"unknown",C=typeof o.get_recorded_frame_count=="function"?o.get_recorded_frame_count():0,D=typeof o.is_recording=="function"?o.is_recording():!1;self.postMessage({type:"recorderState",state:d,frameCount:C,queueSize:0,isCppRecording:D,isWorkerRecording:c})}catch(d){console.error("[Worker] Exception during getState:",d),self.postMessage({type:"recorderState",state:"error_getting_state",frameCount:0,queueSize:0})}break;default:console.warn("[Worker] Unknown message type:",e.type)}}catch(r){console.error("[Worker] Error:",r),self.postMessage({type:"error",error:r.message})}};async function E(){try{if(console.log("[Worker] Stopping recording and finalizing..."),c=!1,i.length>0&&(console.log(`[Worker] Processing ${i.length} remaining frames before stopping`),await _()),o.stop_recording()){console.log("[Worker] Recording stopped successfully, getting data");const e=o.get_recording_data();if(e&&e.length>0){console.log(`[Worker] Got ${e.length} bytes of video data`);const r=Array.from(e.slice(0,16)).map(f=>f.toString(16).padStart(2,"0")).join(" ");if(console.log("[Worker] First 16 bytes:",r),e.length<1e3)throw new Error("Video data too small, likely corrupted");const s=new ArrayBuffer(e.length),l=new Uint8Array(s);l.set(e);const g=o.get_recorded_frame_count()||0;console.log(`[Worker] Final frame count: ${g}`),l[4]===102&&l[5]===116&&l[6]===121&&l[7]===112||(console.warn("[Worker] Warning: MP4 header not detected. Expected ftyp box (66 74 79 70)"),console.warn("[Worker] Got:",r)),self.postMessage({type:"recordingStopped",success:!0,videoData:l,frameCount:g,mimeType:'video/mp4; codecs="avc1.42E01E"',duration:g/30},[s])}else console.error("[Worker] No video data returned"),self.postMessage({type:"recordingStopped",success:!1,error:"No video data available"})}else{const e=F();console.error("[Worker] stop_recording failed:",e),self.postMessage({type:"recordingStopped",success:!1,error:`Stop recording failed: ${e}`})}}catch(t){console.error("[Worker] Exception during stopRecording:",t),self.postMessage({type:"recordingStopped",success:!1,error:"Exception: "+(t.message||t.toString())})}}self.addEventListener("error",t=>{if(console.error("[Worker Global Error]:",t.message,t.filename,t.lineno),self.postMessage)try{self.postMessage({type:"error",error:"Worker error: "+t.message})}catch(e){console.error("[Worker Global Error] Could not send error message",e)}}),self.addEventListener("unhandledrejection",t=>{if(console.error("[Worker Global Error] Unhandled Promise Rejection:",t.reason),self.postMessage)try{self.postMessage({type:"error",error:"Worker promise rejection: "+(t.reason.message||t.reason.toString())})}catch(e){console.error("[Worker Global Error] Could not send rejection message",e)}}),console.log("[Worker] H.264/MP4 video encoding worker initialized")})();
