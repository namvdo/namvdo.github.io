(function(){"use strict";let o,c=0,g=!1,_=!1,a=[],y=!1;const S=30;let w=null,h=[];const e=(i,r=null)=>{const s=`[${new Date().toISOString().slice(11,23)}] [Worker] ${i}`;console.log(s,r||"")};async function M(i){if(e("Initializing with WASM URL:",i),!i)throw new Error("WASM URL not provided");try{e("Attempting to import module factory...");const n=await import(i);e("Module factory loaded successfully");const u={print:l=>e("[WASM Print]",l),printErr:l=>e("[WASM Error]",l),locateFile:l=>(e("Locating file:",l),i.replace("lux.js",l)),importMemory:!0};e("Creating module instance with config..."),o=await n.default(u),e("Module instance created successfully")}catch(n){throw e("CRITICAL ERROR - Failed to initialize module:",n.message),e("Error stack:",n.stack),new Error(`Module initialization failed: ${n.message}`)}const r=Object.keys(o).filter(n=>typeof o[n]=="function");e("Module exports count:",r.length),e("First 10 exports:",r.slice(0,10));const s=["start_recording","stop_recording","get_recording_data","get_recorded_frame_count","get_recording_state","get_recording_error","is_recording","worker_add_frame"].filter(n=>!(o&&typeof o[n]=="function"));if(s.length===0)e("✓ All critical recording functions verified");else throw e(`ERROR - Missing required recording functions: [${s.join(", ")}]`),new Error(`Module recording functions missing: ${s.join(", ")}`)}function W(){if(o&&typeof o.get_recording_error=="function")try{return o.get_recording_error()}catch(i){return console.error("[Worker Helper] Failed to get C++ error:",i),"Failed to get C++ error: "+(i.message||i)}return"Module or get_recording_error not available"}async function k(){if(console.log("[Worker] === PROCESS FRAME QUEUE START ==="),console.log("[Worker] isProcessingFrames:",y),console.log("[Worker] frameQueue.length:",a.length),console.log("[Worker] recordingInProgress:",g),y||a.length===0){console.log("[Worker] Skipping frame processing - already processing or empty queue");return}y=!0;const i=5;console.log("[Worker] Starting frame processing with batch size:",i);try{for(;a.length>0&&g;){const r=a.splice(0,i);console.log("[Worker] Processing batch of",r.length,"frames. Remaining in queue:",a.length);for(const t of r){const s=performance.now();try{if(console.log(`[Worker] === PROCESSING FRAME ${c+1} ===`),console.log(`[Worker] Frame dimensions: ${t.width}x${t.height}`),console.log("[Worker] Frame imageData type:",t.imageData.constructor.name),console.log("[Worker] Frame imageData length:",t.imageData.length),console.log("[Worker] Expected length:",t.width*t.height*4),console.log(`[Worker] Queue remaining: ${a.length}, recording: ${g}`),!o||typeof o.worker_add_frame!="function"){console.error("[Worker] CppModule or worker_add_frame not available"),console.error("[Worker] - CppModule:",!!o),console.error("[Worker] - worker_add_frame type:",typeof(o&&o.worker_add_frame));continue}if(!t.imageData||!t.width||!t.height){console.error("[Worker] Invalid frame data:",{hasImageData:!!t.imageData,width:t.width,height:t.height});continue}console.log("[Worker] Calling CppModule.worker_add_frame...");const n=o.worker_add_frame(t.imageData,t.width,t.height);console.log("[Worker] worker_add_frame returned:",n);const l=performance.now()-s;if(h.push(l),n){if(c++,console.log(`[Worker] ✓ Frame ${c} added successfully in ${l.toFixed(2)}ms`),c%10===0){const f=h.reduce((p,C)=>p+C,0)/h.length,m=(performance.now()-w)/1e3,R=c/m;console.log(`[Worker] Performance metrics:
                                Frame #${c}
                                Queue size: ${a.length}
                                Avg processing time: ${f.toFixed(2)}ms
                                Total duration: ${m.toFixed(2)}s
                                Actual FPS: ${R.toFixed(2)}
                                Target FPS: 30`),self.postMessage({type:"recordingProgress",frameCount:c,metrics:{avgProcessingTime:f,totalDuration:m,actualFps:R,queueSize:a.length}}),h=[]}}else{if(console.error(`[Worker] ✗ Failed to add frame ${c+1} - C++ function returned false`),typeof o.get_recording_error=="function"){const f=o.get_recording_error();console.error(`[Worker] C++ error: ${f}`)}if(typeof o.get_recording_state=="function"){const f=o.get_recording_state();console.error(`[Worker] Recording state: ${f}`)}if(typeof o.is_recording=="function"){const f=o.is_recording();console.error(`[Worker] C++ is_recording: ${f}`)}}}catch(n){console.error(`[Worker] ✗ Exception adding frame ${c+1}:`,n),console.error("[Worker] Frame data:",{hasImageData:!!t.imageData,imageDataLength:t.imageData?t.imageData.length:0,width:t.width,height:t.height,expectedLength:t.width*t.height*4})}}await new Promise(t=>setTimeout(t,0))}}finally{y=!1,console.log("[Worker] === PROCESS FRAME QUEUE END ==="),console.log("[Worker] Final queue size:",a.length),console.log("[Worker] Total frames processed:",c)}}self.onmessage=async i=>{const r=i.data;e("Received message:",r.type);try{switch(r.type){case"init":if(_){e("Already initialized");return}e("Initializing worker..."),await M(r.wasmUrl),_=!0,e("✓ Worker initialization complete"),self.postMessage({type:"initialized"});break;case"startRecording":if(e("=== START RECORDING REQUEST ==="),e("isInitialized:",_),e("recordingInProgress:",g),!_)throw e("ERROR: Worker not initialized"),new Error("Worker not initialized");g&&(e("Already recording, stopping first"),await E()),e("Starting H.264/MP4 recording with options:",r.options),e("Original options dimensions:",r.options.width,"x",r.options.height),g=!0,c=0,w=performance.now(),h=[],e("Using adaptive canvas dimensions for recording...");let t=r.options.width,s=r.options.height;t%2!==0&&(t=t-1,e(`Adjusted width to even number: ${t}`)),s%2!==0&&(s=s-1,e(`Adjusted height to even number: ${s}`));const n=1920,u=16;if((t>n||s>n)&&e(`WARNING: Large dimensions (${t}x${s}) may cause issues on mobile devices`),t<u||s<u){e(`ERROR: Dimensions too small (${t}x${s}), minimum is ${u}x${u}`),g=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Dimensions too small for H.264 encoding"});return}e(`Final recording dimensions: ${t}x${s}`),e(`Original canvas dimensions: ${r.options.width}x${r.options.height}`);const l=o.get_buf_width(),f=o.get_buf_height();e(`Buffer dimensions (for reference): ${l}x${f}`),e("Calling C++ start_recording with CANVAS dimensions:"),e("- Width:",t),e("- Height:",s),e("- FPS:",r.options.fps),e("- Bitrate:",r.options.bitrate),e("- Codec:",r.options.codec),e("- Format:",r.options.format),e("- Preset:",r.options.preset);const m=await o.start_recording(t,s,r.options.fps,r.options.bitrate,r.options.codec,r.options.format,r.options.preset);if(e("start_recording returned:",m),m){if(e("✓ Recording started successfully"),typeof o.get_recording_state=="function"){const d=o.get_recording_state();e("C++ recording state after start:",d)}if(typeof o.is_recording=="function"){const d=o.is_recording();e("C++ is_recording after start:",d)}self.postMessage({type:"recordingStarted",success:!0})}else{if(e("✗ Failed to start H.264 recording"),typeof o.get_recording_error=="function"){const d=o.get_recording_error();e("C++ error:",d)}g=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Failed to start H.264 recording"})}break;case"addFrame":if(e("=== ADD FRAME REQUEST ==="),e("CppModule available:",!!o),e("worker_add_frame available:",!!(o&&o.worker_add_frame)),e("recordingInProgress:",g),!o||!o.worker_add_frame||!g){e("Ignoring frame - not ready or not recording"),e("- CppModule:",!!o),e("- worker_add_frame:",!!(o&&o.worker_add_frame)),e("- recordingInProgress:",g);return}if(e("Frame data validation:"),e("- hasImageData:",!!r.imageData),e("- width:",r.width),e("- height:",r.height),e("- imageData type:",r.imageData?r.imageData.constructor.name:"null"),e("- imageData length:",r.imageData?r.imageData.length:0),e("- expected length:",r.width*r.height*4),!r.imageData||!r.width||!r.height){e("Invalid frame data:",{hasImageData:!!r.imageData,width:r.width,height:r.height});return}if(typeof o.get_recording_state=="function"){const d=o.get_recording_state();e("Current C++ recording state:",d)}if(typeof o.is_recording=="function"){const d=o.is_recording();e("C++ is_recording:",d)}e("Adding frame to queue. Current queue size:",a.length),a.push({imageData:r.imageData,width:r.width,height:r.height}),e("Frame added to queue. New queue size:",a.length),a.length>=S&&(e("Queue size reached MAX_QUEUE_SIZE, processing frames"),k());break;case"stopRecording":if(!g){e("Not recording");return}const p=(performance.now()-w)/1e3;e(`Recording stopped after ${p.toFixed(2)}s with ${c} frames`),e(`Average FPS: ${(c/p).toFixed(2)}`),g=!1,a.length>0&&await k();const C=await E();self.postMessage({...C,metrics:{totalDuration:p,totalFrames:c,averageFps:c/p}});break;case"getState":if(!o){self.postMessage({type:"recorderState",state:"module_not_ready",frameCount:0,queueSize:0});return}try{const d=typeof o.get_recording_state=="function"?o.get_recording_state():"unknown",F=typeof o.get_recorded_frame_count=="function"?o.get_recorded_frame_count():0,$=typeof o.is_recording=="function"?o.is_recording():!1;self.postMessage({type:"recorderState",state:d,frameCount:F,queueSize:0,isCppRecording:$,isWorkerRecording:g})}catch(d){e("Exception during getState:",d.message),self.postMessage({type:"recorderState",state:"error_getting_state",frameCount:0,queueSize:0})}break;default:e("Unknown message type:",r.type)}}catch(t){e("CRITICAL ERROR in message handler:",t.message),e("Error stack:",t.stack),self.postMessage({type:"error",error:t.message})}};async function E(){try{if(e("Stopping recording and finalizing..."),g=!1,a.length>0&&(e(`Processing ${a.length} remaining frames before stopping`),await k()),o.stop_recording()){e("Recording stopped successfully, getting data");const r=o.get_recording_data();if(r&&r.length>0){e(`Got ${r.length} bytes of video data`);const t=Array.from(r.slice(0,16)).map(f=>f.toString(16).padStart(2,"0")).join(" ");if(e("First 16 bytes:",t),r.length<1e3)throw new Error("Video data too small, likely corrupted");const s=new ArrayBuffer(r.length),n=new Uint8Array(s);n.set(r);const u=o.get_recorded_frame_count()||0;e(`Final frame count: ${u}`),n[4]===102&&n[5]===116&&n[6]===121&&n[7]===112||(e("Warning: MP4 header not detected. Expected ftyp box (66 74 79 70)"),e("Got:",t)),self.postMessage({type:"recordingStopped",success:!0,videoData:n,frameCount:u,mimeType:'video/mp4; codecs="avc1.42E01E"',duration:u/30},[s])}else e("No video data returned"),self.postMessage({type:"recordingStopped",success:!1,error:"No video data available"})}else{const r=W();e("stop_recording failed:",r),self.postMessage({type:"recordingStopped",success:!1,error:`Stop recording failed: ${r}`})}}catch(i){e("Exception during stopRecording:",i),self.postMessage({type:"recordingStopped",success:!1,error:"Exception: "+(i.message||i.toString())})}}self.addEventListener("error",i=>{if(e("CRITICAL ERROR in global error handler:",i.message,i.filename,i.lineno),self.postMessage)try{self.postMessage({type:"error",error:"Worker error: "+i.message})}catch{e("CRITICAL ERROR: Could not send error message")}}),self.addEventListener("unhandledrejection",i=>{if(e("CRITICAL ERROR in global error handler:",i.reason),self.postMessage)try{self.postMessage({type:"error",error:"Worker promise rejection: "+(i.reason.message||i.reason.toString())})}catch{e("CRITICAL ERROR: Could not send rejection message")}}),e("H.264/MP4 video encoding worker initialized")})();
