(function(){"use strict";let t,g=0,u=!1,C=!1,a=[],p=!1;const S=30;let k=null,M=null,h=[];const e=(s,r=null)=>{const i=`[${new Date().toISOString().slice(11,23)}] [Worker] ${s}`;console.log(i,r||"")};function W(){return new Promise((s,r)=>{let i=0;const d=setInterval(()=>{i++,e(`Checking main thread WASM readiness... attempt ${i}/50`),self.postMessage({type:"checkMainThreadReady"}),i>=50&&(clearInterval(d),r(new Error("Main thread WASM not ready after 5 seconds")))},100),l=c=>{c.data.type==="mainThreadReady"&&(clearInterval(d),self.removeEventListener("message",l),c.data.ready?(e("✓ Main thread WASM is ready"),s()):r(new Error("Main thread WASM is not ready")))};self.addEventListener("message",l)})}async function $(){e("Worker initialization - loading WASM after main thread sync...");try{await W(),e("Getting confirmation from main thread..."),await new Promise((c,n)=>{const m=_=>{_.data.type==="wasmModuleResponse"&&(self.removeEventListener("message",m),_.data.success?(e("✓ Main thread confirmed ready, proceeding with worker WASM load"),c()):n(new Error(_.data.error||"Main thread not ready")))};self.addEventListener("message",m),self.postMessage({type:"getWasmModule"}),setTimeout(()=>{self.removeEventListener("message",m),n(new Error("Timeout waiting for main thread confirmation"))},1e4)}),e("Loading worker WASM instance...");let i;const d=["/lux.js","/assets/lux.js","./lux.js"];for(const c of d)try{e(`Trying to load module from: ${c}`);const n=await import(c);i=n.default||n,e(`✓ Successfully loaded module from: ${c}`);break}catch(n){e(`✗ Failed to load from ${c}: ${n.message}`)}if(!i)throw new Error("Could not load lux.js from any of the attempted paths");const l={print:c=>e("[WASM Print]",c),printErr:c=>e("[WASM Error]",c),locateFile:c=>(e("Locating file:",c),c.endsWith(".wasm")?`/assets/${c}`:c),importMemory:!0};e("Creating worker WASM instance with config..."),t=await i(l),e("✓ Worker WASM instance created successfully")}catch(i){throw e("CRITICAL ERROR - Failed to initialize module:",i.message),e("Error stack:",i.stack),new Error(`Module initialization failed: ${i.message}`)}const s=Object.keys(t).filter(i=>typeof t[i]=="function");e("Module exports count:",s.length),e("First 10 exports:",s.slice(0,10));const r=["start_recording","stop_recording","get_recording_data","get_recorded_frame_count","get_recording_state","get_recording_error","is_recording","worker_add_frame"];e("Checking each required function:"),r.forEach(i=>{const d=t&&typeof t[i]=="function";e(`- ${i}: ${d?"✓":"✗"} (${typeof t[i]})`)});const o=r.filter(i=>!(t&&typeof t[i]=="function"));if(o.length===0){e("✓ All critical recording functions verified");try{if(typeof t.get_recording_state=="function"){const n=t.get_recording_state();e("Initial recording state:",n)}e("Searching for initialization functions...");const d=Object.keys(t).filter(n=>typeof t[n]=="function").filter(n=>n.toLowerCase().includes("init")||n.toLowerCase().includes("setup")||n.toLowerCase().includes("recorder")||n.toLowerCase().includes("video"));e("All functions that might be related to initialization:",d);const l=["init_video_recorder","initialize_recorder","init_recorder","recorder_init","video_init","init_video","setup_recorder","setup_video_recorder","video_recorder_init","recorder_initialize","initialize_video_recorder","initialize_video","recorder_setup","video_setup",...d];let c=!1;for(const n of l)if(typeof t[n]=="function")try{e(`Found initialization function: ${n}, calling it...`);const m=t[n]();e(`${n} returned:`,m),c=!0;break}catch(m){e(`Warning: ${n} failed:`,m.message)}if(!c&&(e("No video recorder initialization function found, trying automatic init..."),typeof t.get_recording_state=="function")){const n=t.get_recording_state();e("Recording state after init attempt:",n)}}catch(i){e("Warning: Could not initialize video recorder:",i.message)}}else throw e(`ERROR - Missing required recording functions: [${o.join(", ")}]`),new Error(`Module recording functions missing: ${o.join(", ")}`)}function v(){if(t&&typeof t.get_recording_error=="function")try{return t.get_recording_error()}catch(s){return console.error("[Worker Helper] Failed to get C++ error:",s),"Failed to get C++ error: "+(s.message||s)}return"Module or get_recording_error not available"}async function R(){if(console.log("[Worker] === PROCESS FRAME QUEUE START ==="),console.log("[Worker] isProcessingFrames:",p),console.log("[Worker] frameQueue.length:",a.length),console.log("[Worker] recordingInProgress:",u),p||a.length===0){console.log("[Worker] Skipping frame processing - already processing or empty queue");return}p=!0;const s=5;console.log("[Worker] Starting frame processing with batch size:",s);try{for(;a.length>0;){const r=a.splice(0,s);console.log("[Worker] Processing batch of",r.length,"frames. Remaining in queue:",a.length);for(const o of r){const i=performance.now();try{if(console.log(`[Worker] === PROCESSING FRAME ${g+1} ===`),console.log(`[Worker] Frame dimensions: ${o.width}x${o.height}`),console.log("[Worker] Frame imageData type:",o.imageData.constructor.name),console.log("[Worker] Frame imageData length:",o.imageData.length),console.log("[Worker] Expected length:",o.width*o.height*4),console.log(`[Worker] Queue remaining: ${a.length}, recording: ${u}`),!t||typeof t.worker_add_frame!="function"){console.error("[Worker] CppModule or worker_add_frame not available"),console.error("[Worker] - CppModule:",!!t),console.error("[Worker] - worker_add_frame type:",typeof(t&&t.worker_add_frame));continue}if(!o.imageData||!o.width||!o.height){console.error("[Worker] Invalid frame data:",{hasImageData:!!o.imageData,width:o.width,height:o.height});continue}console.log("[Worker] Calling CppModule.worker_add_frame...");const d=t.worker_add_frame(o.imageData,o.width,o.height);console.log("[Worker] worker_add_frame returned:",d);const c=performance.now()-i;if(h.push(c),d){if(g++,console.log(`[Worker] ✓ Frame ${g} added successfully in ${c.toFixed(2)}ms`),g%10===0){const n=h.reduce((w,E)=>w+E,0)/h.length,m=(performance.now()-k)/1e3,_=g/m;console.log(`[Worker] Performance metrics:
                                Frame #${g}
                                Queue size: ${a.length}
                                Avg processing time: ${n.toFixed(2)}ms
                                Total duration: ${m.toFixed(2)}s
                                Actual FPS: ${_.toFixed(2)}
                                Target FPS: 30`),self.postMessage({type:"recordingProgress",frameCount:g,metrics:{avgProcessingTime:n,totalDuration:m,actualFps:_,queueSize:a.length}}),h=[]}}else{if(console.error(`[Worker] ✗ Failed to add frame ${g+1} - C++ function returned false`),typeof t.get_recording_error=="function"){const n=t.get_recording_error();console.error(`[Worker] C++ error: ${n}`)}if(typeof t.get_recording_state=="function"){const n=t.get_recording_state();console.error(`[Worker] Recording state: ${n}`)}if(typeof t.is_recording=="function"){const n=t.is_recording();console.error(`[Worker] C++ is_recording: ${n}`)}}}catch(d){console.error(`[Worker] ✗ Exception adding frame ${g+1}:`,d),console.error("[Worker] Frame data:",{hasImageData:!!o.imageData,imageDataLength:o.imageData?o.imageData.length:0,width:o.width,height:o.height,expectedLength:o.width*o.height*4})}}await new Promise(o=>setTimeout(o,0))}}finally{p=!1,console.log("[Worker] === PROCESS FRAME QUEUE END ==="),console.log("[Worker] Final queue size:",a.length),console.log("[Worker] Total frames processed:",g)}}self.onmessage=async s=>{const r=s.data;e("Received message:",r.type);try{switch(r.type){case"init":if(C){e("Already initialized");return}e("Initializing worker..."),await $(),C=!0,e("✓ Worker initialization complete"),self.postMessage({type:"initialized"});break;case"startRecording":if(e("=== START RECORDING REQUEST ==="),e("isInitialized:",C),e("recordingInProgress:",u),!C)throw e("ERROR: Worker not initialized"),new Error("Worker not initialized");u&&(e("Already recording, stopping first"),await F()),e("Resetting recording state for fresh start..."),g=0,a=[],p=!1,k=performance.now(),M=null,h=[],e("Recording state reset complete:",{frameCount:g,queueLength:a.length,isProcessingFrames:p}),e("Starting H.264/MP4 recording with options:",r.options),e("Original options dimensions:",r.options.width,"x",r.options.height),u=!0,e("Using adaptive canvas dimensions for recording...");let o=r.options.width,i=r.options.height;o%2!==0&&(o=o-1,e(`Adjusted width to even number: ${o}`)),i%2!==0&&(i=i-1,e(`Adjusted height to even number: ${i}`));const d=1920,l=16;if((o>d||i>d)&&e(`WARNING: Large dimensions (${o}x${i}) may cause issues on mobile devices`),o<l||i<l){e(`ERROR: Dimensions too small (${o}x${i}), minimum is ${l}x${l}`),u=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Dimensions too small for H.264 encoding"});return}e(`Final recording dimensions: ${o}x${i}`),e(`Original canvas dimensions: ${r.options.width}x${r.options.height}`);const c=t.get_buf_width(),n=t.get_buf_height();e(`Buffer dimensions (for reference): ${c}x${n}`),e("Calling C++ start_recording with CANVAS dimensions:"),e("- Width:",o),e("- Height:",i),e("- FPS:",r.options.fps),e("- Bitrate:",r.options.bitrate),e("- Codec:",r.options.codec),e("- Format:",r.options.format),e("- Preset:",r.options.preset);const m=await t.start_recording(o,i,r.options.fps,r.options.bitrate,r.options.codec,r.options.format,r.options.preset);if(e("start_recording returned:",m),m){if(e("✓ Recording started successfully"),typeof t.get_recording_state=="function"){const f=t.get_recording_state();e("C++ recording state after start:",f)}if(typeof t.is_recording=="function"){const f=t.is_recording();e("C++ is_recording after start:",f)}a.length>0&&(e(`Processing ${a.length} frames that were queued while waiting for backend`),R()),self.postMessage({type:"recordingStarted",success:!0})}else{e("✗ Failed to start H.264 recording");let f="Unknown error";if(typeof t.get_recording_error=="function")try{f=t.get_recording_error(),e("C++ error details:",f)}catch(y){e("Failed to get C++ error:",y.message)}if(e("Checking recording function availability:"),e("- start_recording:",typeof t.start_recording),e("- stop_recording:",typeof t.stop_recording),e("- get_recording_data:",typeof t.get_recording_data),e("- get_recording_error:",typeof t.get_recording_error),typeof t.get_recording_state=="function")try{const y=t.get_recording_state();e("Current recording state:",y)}catch(y){e("Failed to get recording state:",y.message)}u=!1,a.length>0&&(e(`Clearing ${a.length} queued frames due to recording failure`),a=[]),self.postMessage({type:"recordingStarted",success:!1,error:`Failed to start H.264 recording: ${f}`})}break;case"addFrame":if(e("=== ADD FRAME REQUEST ==="),e("CppModule available:",!!t),e("worker_add_frame available:",!!(t&&t.worker_add_frame)),e("recordingInProgress:",u),!u){e("Rejecting frame - recording not in progress");return}if(!t||!t.worker_add_frame){e("Module not ready, queuing frame for when backend is ready"),e("- CppModule:",!!t),e("- worker_add_frame:",!!(t&&t.worker_add_frame)),r.imageData&&r.width&&r.height&&(a.push({imageData:r.imageData,width:r.width,height:r.height}),e("Frame queued while waiting for backend. Queue size:",a.length));return}if(e("Frame data validation:"),e("- hasImageData:",!!r.imageData),e("- width:",r.width),e("- height:",r.height),e("- imageData type:",r.imageData?r.imageData.constructor.name:"null"),e("- imageData length:",r.imageData?r.imageData.length:0),e("- expected length:",r.width*r.height*4),!r.imageData||!r.width||!r.height){e("Invalid frame data:",{hasImageData:!!r.imageData,width:r.width,height:r.height});return}if(typeof t.get_recording_state=="function"){const f=t.get_recording_state();e("Current C++ recording state:",f)}if(typeof t.is_recording=="function"){const f=t.is_recording();if(e("C++ is_recording:",f),!f){e("C++ not ready yet, queuing frame"),a.push({imageData:r.imageData,width:r.width,height:r.height}),e("Frame queued waiting for C++ ready. Queue size:",a.length);return}}e("Adding frame to queue. Current queue size:",a.length),a.push({imageData:r.imageData,width:r.width,height:r.height}),e("Frame added to queue. New queue size:",a.length),a.length>=S&&(e("Queue size reached MAX_QUEUE_SIZE, processing frames"),R());break;case"stopRecording":if(!u){e("Not recording");return}const w=(performance.now()-k)/1e3;e(`Recording stopped after ${w.toFixed(2)}s with ${g} frames`),e(`Average FPS: ${(g/w).toFixed(2)}`),u=!1,r.flushQueue?(e(`Flushing ${a.length} remaining frames from queue (will not be processed)`),a=[],e("Frame queue flushed - starting clean for next recording")):a.length>0&&(e(`Processing ${a.length} remaining frames before stopping`),await R());const E=await F();self.postMessage({...E,metrics:{totalDuration:w,totalFrames:g,averageFps:g/w}});break;case"getState":if(!t){self.postMessage({type:"recorderState",state:"module_not_ready",frameCount:0,queueSize:0});return}try{const f=typeof t.get_recording_state=="function"?t.get_recording_state():"unknown",y=typeof t.get_recorded_frame_count=="function"?t.get_recorded_frame_count():0,x=typeof t.is_recording=="function"?t.is_recording():!1;self.postMessage({type:"recorderState",state:f,frameCount:y,queueSize:0,isCppRecording:x,isWorkerRecording:u})}catch(f){e("Exception during getState:",f.message),self.postMessage({type:"recorderState",state:"error_getting_state",frameCount:0,queueSize:0})}break;default:e("Unknown message type:",r.type)}}catch(o){e("CRITICAL ERROR in message handler:",o.message),e("Error stack:",o.stack),self.postMessage({type:"error",error:o.message})}};async function F(){try{if(e("Stopping recording and finalizing..."),u=!1,p=!1,a.length>0&&(e(`Processing ${a.length} remaining frames before stopping`),await R()),t.stop_recording()){e("Recording stopped successfully, getting data");const r=t.get_recording_data();if(r&&r.length>0){e(`Got ${r.length} bytes of video data`);const o=Array.from(r.slice(0,16)).map(n=>n.toString(16).padStart(2,"0")).join(" ");if(e("First 16 bytes:",o),r.length<1e3)throw new Error("Video data too small, likely corrupted");const i=new ArrayBuffer(r.length),d=new Uint8Array(i);d.set(r);const l=t.get_recorded_frame_count()||0;e(`Final frame count: ${l}`),d[4]===102&&d[5]===116&&d[6]===121&&d[7]===112||(e("Warning: MP4 header not detected. Expected ftyp box (66 74 79 70)"),e("Got:",o)),e("Cleaning up state for next recording..."),a=[],p=!1,g=0,k=null,M=null,h=[],e("State cleanup complete:",{frameQueue:a.length,isProcessingFrames:p,frameCount:g}),self.postMessage({type:"recordingStopped",success:!0,videoData:d,frameCount:l,mimeType:'video/mp4; codecs="avc1.42E01E"',duration:l/30},[i])}else e("No video data returned"),self.postMessage({type:"recordingStopped",success:!1,error:"No video data available"})}else{const r=v();e("stop_recording failed:",r),self.postMessage({type:"recordingStopped",success:!1,error:`Stop recording failed: ${r}`})}}catch(s){e("Exception during stopRecording:",s),self.postMessage({type:"recordingStopped",success:!1,error:"Exception: "+(s.message||s.toString())})}finally{e("Final cleanup - ensuring clean state..."),u=!1,p=!1,a=[],g=0,k=null,M=null,h=[],e("Final cleanup complete - ready for next recording")}}self.addEventListener("error",s=>{if(e("CRITICAL ERROR in global error handler:",s.message,s.filename,s.lineno),self.postMessage)try{self.postMessage({type:"error",error:"Worker error: "+s.message})}catch{e("CRITICAL ERROR: Could not send error message")}}),self.addEventListener("unhandledrejection",s=>{if(e("CRITICAL ERROR in global error handler:",s.reason),self.postMessage)try{self.postMessage({type:"error",error:"Worker promise rejection: "+(s.reason.message||s.reason.toString())})}catch{e("CRITICAL ERROR: Could not send rejection message")}}),e("H.264/MP4 video encoding worker initialized - v1.2 with sync loading fix")})();
