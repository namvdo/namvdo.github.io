(function(){"use strict";let n,c=0,g=!1,k=!1,d=[],W=!1;const b=30;let y=null,m=[];async function A(e){if(console.log("[Worker] Initializing with WASM URL:",e),!e)throw new Error("WASM URL not provided");const r=await import(e);console.log("[Worker] Module factory loaded.");const s={print:t=>console.log("[WASM Print]",t),printErr:t=>console.error("[WASM Error]",t),locateFile:t=>(console.log("[Worker] Locating file:",t),e.replace("lux.js",t)),importMemory:!0};try{n=await r.default(s),console.log("[Worker] Module instance created.")}catch(t){throw console.error("[Worker] Failed to initialize module:",t),new Error(`Module initialization failed: ${t.message}`)}const i=Object.keys(n).filter(t=>typeof n[t]=="function");console.log("[Worker] Module exports:",i);const l=["start_recording","stop_recording","get_recording_data","get_recorded_frame_count","get_recording_state","get_recording_error","is_recording","worker_add_frame"].filter(t=>!(n&&typeof n[t]=="function"));if(l.length===0)console.log("[Worker] Critical recording functions verified.");else throw console.error(`[Worker] Missing required recording functions: [${l.join(", ")}]`),new Error(`Module recording functions missing: ${l.join(", ")}`)}function w(){if(n&&typeof n.get_recording_error=="function")try{const e=n.get_recording_error();return console.log("[Worker] C++ Error Details:",e),e||"No specific error available"}catch(e){return console.error("[Worker Helper] Failed to get C++ error:",e),"Failed to get C++ error: "+(e.message||e)}return"Module or get_recording_error not available"}function S(e,r,s=null){const i={context:e,cppError:r,jsError:s?s.message||s.toString():null,timestamp:new Date().toISOString(),recordingState:g,frameCount:c,queueSize:d.length};console.error("[Worker] Detailed Error Report:",i);const o=`${e}: C++[${r}]${s?` JS[${i.jsError}]`:""}`;return self.postMessage({type:"error",error:o,details:i}),o}async function _(){if(W||d.length===0)return;W=!0;const e=5;try{for(;d.length>0&&g;){const r=d.splice(0,e);for(const s of r){const i=performance.now();try{const o=n.worker_add_frame(s.imageData,s.width,s.height),t=performance.now()-i;if(m.push(t),o){if(c++,c%30===0){const p=m.reduce((u,E)=>u+E,0)/m.length,f=(performance.now()-y)/1e3,a=c/f;console.log(`[Worker] Performance metrics:
                                Frame #${c}
                                Queue size: ${d.length}
                                Avg processing time: ${p.toFixed(2)}ms
                                Total duration: ${f.toFixed(2)}s
                                Actual FPS: ${a.toFixed(2)}
                                Target FPS: 30`),self.postMessage({type:"recordingProgress",frameCount:c,metrics:{avgProcessingTime:p,totalDuration:f,actualFps:a,queueSize:d.length}}),m=[]}}else console.error("[Worker] Failed to add frame"),self.postMessage({type:"error",error:"Failed to add frame"})}catch(o){console.error("[Worker] Error adding frame:",o),self.postMessage({type:"error",error:"Error adding frame: "+o.message})}}await new Promise(s=>setTimeout(s,0))}}finally{W=!1}}self.onmessage=async e=>{const r=e.data;console.log("[Worker] Received message:",r.type);try{switch(r.type){case"init":if(k){console.log("[Worker] Already initialized");return}console.log("[Worker] Initializing..."),await A(r.wasmUrl),k=!0,self.postMessage({type:"initialized"});break;case"startRecording":if(!k)throw new Error("Worker not initialized");g&&(console.log("[Worker] Already recording, stopping first"),await M()),console.log("[Worker] Starting recording with options:",r.options),g=!0,c=0,y=performance.now(),m=[];const s=n.get_buf_width(),i=n.get_buf_height();await n.start_recording(r.options.width,r.options.height,r.options.fps,r.options.bitrate,r.options.codec,r.options.format,r.options.preset)?self.postMessage({type:"recordingStarted",success:!0}):(g=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Failed to start recording"}));break;case"addFrame":if(!n||!n.worker_add_frame||!g){console.warn("[Worker] Ignoring frame - not ready or not recording");return}if(!r.imageData||!r.width||!r.height){console.error("[Worker] Invalid frame data:",{hasImageData:!!r.imageData,width:r.width,height:r.height});return}d.push({imageData:r.imageData,width:r.width,height:r.height}),d.length>=b&&_();break;case"stopRecording":if(!g){console.log("[Worker] Not recording");return}const t=(performance.now()-y)/1e3;console.log(`[Worker] Recording stopped after ${t.toFixed(2)}s with ${c} frames`),console.log(`[Worker] Average FPS: ${(c/t).toFixed(2)}`),g=!1,d.length>0&&await _();const p=await M();self.postMessage({...p,metrics:{totalDuration:t,totalFrames:c,averageFps:c/t}});break;case"getState":if(!n){self.postMessage({type:"recorderState",state:"module_not_ready",frameCount:0,queueSize:0});return}try{const f=typeof n.get_recording_state=="function"?n.get_recording_state():"unknown",a=typeof n.get_recorded_frame_count=="function"?n.get_recorded_frame_count():0,u=typeof n.is_recording=="function"?n.is_recording():!1;self.postMessage({type:"recorderState",state:f,frameCount:a,queueSize:0,isCppRecording:u,isWorkerRecording:g})}catch(f){console.error("[Worker] Exception during getState:",f),self.postMessage({type:"recorderState",state:"error_getting_state",frameCount:0,queueSize:0})}break;default:console.warn("[Worker] Unknown message type:",r.type)}}catch(s){console.error("[Worker] Error:",s),self.postMessage({type:"error",error:s.message})}};async function M(){try{console.log("[Worker] Stopping recording and finalizing..."),g=!1,d.length>0&&(console.log(`[Worker] Processing ${d.length} remaining frames before stopping`),await _());const e=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent||""),r=/iPhone|iPad|iPod/i.test(navigator.userAgent||"");e&&(console.log(`[Worker] Mobile device detected: ${r?"iOS":"Android"}`),await new Promise(o=>setTimeout(o,100)));let s=!1,i=null;try{s=n.stop_recording()}catch(o){if(i=o,console.error("[Worker] Exception calling stop_recording:",o),e)console.log("[Worker] Mobile: Attempting to recover partial data after stop failure"),s=!1;else throw o}if(s||e&&!s){console.log(`[Worker] Recording ${s?"stopped successfully":"stopped with warnings (mobile)"}, getting data`);let o=null,l=null;try{o=n.get_recording_data()}catch(t){if(l=t,console.error("[Worker] Exception getting recording data:",t),e)console.log("[Worker] Mobile: Data retrieval failed, this is expected on some devices");else throw t}if(o&&o.length>0){console.log(`[Worker] Got ${o.length} bytes of video data`);const t=Array.from(o.slice(0,16)).map(h=>h.toString(16).padStart(2,"0")).join(" ");console.log("[Worker] First 16 bytes:",t);const p=e?100:1e3;if(o.length<p){const h=`Video data too small for ${e?"mobile":"desktop"}: ${o.length} bytes (min: ${p})`;if(e)console.warn("[Worker] "+h+" - attempting download anyway");else throw new Error(h)}const f=new ArrayBuffer(o.length),a=new Uint8Array(f);a.set(o);const u=n.get_recorded_frame_count()||0;if(console.log(`[Worker] Final frame count: ${u}`),!(a[0]===26&&a[1]===69&&a[2]===223&&a[3]===163))if(console.error("[Worker] Invalid WebM header. Expected EBML header (1A 45 DF A3)"),console.error("[Worker] Got:",t),e)console.log("[Worker] Mobile: Invalid header detected, attempting to fix..."),a.length>4&&(a[0]=26,a[1]=69,a[2]=223,a[3]=163,console.log("[Worker] Mobile: Header fixed"));else throw new Error("Invalid WebM header on desktop");const F=r?"video/webm":'video/webm; codecs="vp8"';self.postMessage({type:"recordingStopped",success:!0,videoData:a,frameCount:u,mimeType:F,duration:u/30,platform:e?r?"iOS":"Android":"Desktop",warnings:s?[]:["Stop recording had warnings but data recovered"]},[f])}else{console.error("[Worker] No video data returned");const t={platform:e?r?"iOS":"Android":"Desktop",stopSuccess:s,stopError:i?i.message:null,dataError:l?l.message:null,frameCount:c||0,arrayLength:o?o.length:0,cppError:w()};console.error("[Worker] Error details:",t),self.postMessage({type:"recordingStopped",success:!1,error:`No video data available (${t.platform})`,details:t})}}else{const o=w();console.error("[Worker] stop_recording failed:",o);const l={platform:e?r?"iOS":"Android":"Desktop",cppError:o,stopError:i?i.message:null,frameCount:c||0,userAgent:navigator.userAgent||"unknown"},t=S("Stop Recording Failed",o);self.postMessage({type:"recordingStopped",success:!1,error:t,details:l})}}catch(e){console.error("[Worker] Exception during stopRecording:",e);const r=w(),s=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent||""),i=/iPhone|iPad|iPod/i.test(navigator.userAgent||""),o={platform:s?i?"iOS":"Android":"Desktop",exception:e.message||e.toString(),cppError:r,stack:e.stack||"No stack trace",frameCount:c||0};console.error("[Worker] Exception details:",o);const l=S("Stop Recording Exception",r,e);self.postMessage({type:"recordingStopped",success:!1,error:l,details:o})}}self.addEventListener("error",e=>{if(console.error("[Worker Global Error]:",e.message,e.filename,e.lineno),self.postMessage)try{self.postMessage({type:"error",error:"Worker error: "+e.message})}catch(r){console.error("[Worker Global Error] Could not send error message",r)}}),self.addEventListener("unhandledrejection",e=>{if(console.error("[Worker Global Error] Unhandled Promise Rejection:",e.reason),self.postMessage)try{self.postMessage({type:"error",error:"Worker promise rejection: "+(e.reason.message||e.reason.toString())})}catch(r){console.error("[Worker Global Error] Could not send rejection message",r)}}),console.log("[Worker] Video encoding worker initialized")})();
