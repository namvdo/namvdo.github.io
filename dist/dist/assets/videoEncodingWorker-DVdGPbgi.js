(function(){"use strict";let o,i=0,c=!1,m=!1,a=[],h=!1;const w=30;let k=null,p=[];async function M(r){if(console.log("[Worker] Initializing with WASM URL:",r),!r)throw new Error("WASM URL not provided");const e=await import(r);console.log("[Worker] Module factory loaded.");const n={print:t=>console.log("[WASM Print]",t),printErr:t=>console.error("[WASM Error]",t),locateFile:t=>(console.log("[Worker] Locating file:",t),r.replace("lux.js",t)),importMemory:!0};try{o=await e.default(n),console.log("[Worker] Module instance created.")}catch(t){throw console.error("[Worker] Failed to initialize module:",t),new Error(`Module initialization failed: ${t.message}`)}const d=Object.keys(o).filter(t=>typeof o[t]=="function");console.log("[Worker] Module exports:",d);const l=["start_recording","stop_recording","get_recording_data","get_recorded_frame_count","get_recording_state","get_recording_error","is_recording","worker_add_frame"].filter(t=>!(o&&typeof o[t]=="function"));if(l.length===0)console.log("[Worker] Critical recording functions verified.");else throw console.error(`[Worker] Missing required recording functions: [${l.join(", ")}]`),new Error(`Module recording functions missing: ${l.join(", ")}`)}function S(){if(o&&typeof o.get_recording_error=="function")try{return o.get_recording_error()}catch(r){return console.error("[Worker Helper] Failed to get C++ error:",r),"Failed to get C++ error: "+(r.message||r)}return"Module or get_recording_error not available"}async function y(){if(h||a.length===0)return;h=!0;const r=5;try{for(;a.length>0&&c;){const e=a.splice(0,r);for(const n of e){const d=performance.now();try{const s=o.worker_add_frame(n.imageData,n.width,n.height),t=performance.now()-d;if(p.push(t),s){if(i++,i%30===0){const g=p.reduce((W,F)=>W+F,0)/p.length,f=(performance.now()-k)/1e3,u=i/f;console.log(`[Worker] Performance metrics:
                                Frame #${i}
                                Queue size: ${a.length}
                                Avg processing time: ${g.toFixed(2)}ms
                                Total duration: ${f.toFixed(2)}s
                                Actual FPS: ${u.toFixed(2)}
                                Target FPS: 30`),self.postMessage({type:"recordingProgress",frameCount:i,metrics:{avgProcessingTime:g,totalDuration:f,actualFps:u,queueSize:a.length}}),p=[]}}else console.error("[Worker] Failed to add frame"),self.postMessage({type:"error",error:"Failed to add frame"})}catch(s){console.error("[Worker] Error adding frame:",s),self.postMessage({type:"error",error:"Error adding frame: "+s.message})}}await new Promise(n=>setTimeout(n,0))}}finally{h=!1}}self.onmessage=async r=>{const e=r.data;console.log("[Worker] Received message:",e.type);try{switch(e.type){case"init":if(m){console.log("[Worker] Already initialized");return}console.log("[Worker] Initializing..."),await M(e.wasmUrl),m=!0,self.postMessage({type:"initialized"});break;case"startRecording":if(!m)throw new Error("Worker not initialized");c&&(console.log("[Worker] Already recording, stopping first"),await _()),console.log("[Worker] Starting recording with options:",e.options),c=!0,i=0,k=performance.now(),p=[];const n=o.get_buf_width(),d=o.get_buf_height();await o.start_recording(e.options.width,e.options.height,e.options.fps,e.options.bitrate,e.options.codec,e.options.format,e.options.preset)?self.postMessage({type:"recordingStarted",success:!0}):(c=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Failed to start recording"}));break;case"addFrame":if(!o||!o.worker_add_frame||!c){console.warn("[Worker] Ignoring frame - not ready or not recording");return}if(!e.imageData||!e.width||!e.height){console.error("[Worker] Invalid frame data:",{hasImageData:!!e.imageData,width:e.width,height:e.height});return}a.push({imageData:e.imageData,width:e.width,height:e.height}),a.length>=w&&y();break;case"stopRecording":if(!c){console.log("[Worker] Not recording");return}const t=(performance.now()-k)/1e3;console.log(`[Worker] Recording stopped after ${t.toFixed(2)}s with ${i} frames`),console.log(`[Worker] Average FPS: ${(i/t).toFixed(2)}`),c=!1,a.length>0&&await y();const g=await _();self.postMessage({...g,metrics:{totalDuration:t,totalFrames:i,averageFps:i/t}});break;case"getState":if(!o){self.postMessage({type:"recorderState",state:"module_not_ready",frameCount:0,queueSize:0});return}try{const f=typeof o.get_recording_state=="function"?o.get_recording_state():"unknown",u=typeof o.get_recorded_frame_count=="function"?o.get_recorded_frame_count():0,W=typeof o.is_recording=="function"?o.is_recording():!1;self.postMessage({type:"recorderState",state:f,frameCount:u,queueSize:0,isCppRecording:W,isWorkerRecording:c})}catch(f){console.error("[Worker] Exception during getState:",f),self.postMessage({type:"recorderState",state:"error_getting_state",frameCount:0,queueSize:0})}break;default:console.warn("[Worker] Unknown message type:",e.type)}}catch(n){console.error("[Worker] Error:",n),self.postMessage({type:"error",error:n.message})}};async function _(){try{if(console.log("[Worker] Stopping recording and finalizing..."),c=!1,a.length>0&&(console.log(`[Worker] Processing ${a.length} remaining frames before stopping`),await y()),o.stop_recording()){console.log("[Worker] Recording stopped successfully, getting data");const e=o.get_recording_data();if(e&&e.length>0){console.log(`[Worker] Got ${e.length} bytes of video data`);const n=Array.from(e.slice(0,16)).map(g=>g.toString(16).padStart(2,"0")).join(" ");if(console.log("[Worker] First 16 bytes:",n),e.length<1e3)throw new Error("Video data too small, likely corrupted");const d=new ArrayBuffer(e.length),s=new Uint8Array(d);s.set(e);const l=o.get_recorded_frame_count()||0;console.log(`[Worker] Final frame count: ${l}`),s[0]===26&&s[1]===69&&s[2]===223&&s[3]===163||(console.error("[Worker] Invalid WebM header. Expected EBML header (1A 45 DF A3)"),console.error("[Worker] Got:",n),s.length>4&&(console.log("[Worker] Attempting to fix WebM header..."),s[0]=26,s[1]=69,s[2]=223,s[3]=163,console.log("[Worker] Header fixed, new header:",Array.from(s.slice(0,4)).map(g=>g.toString(16).padStart(2,"0")).join(" ")))),self.postMessage({type:"recordingStopped",success:!0,videoData:s,frameCount:l,mimeType:'video/webm; codecs="vp8"',duration:l/30},[d])}else console.error("[Worker] No video data returned"),self.postMessage({type:"recordingStopped",success:!1,error:"No video data available"})}else{const e=S();console.error("[Worker] stop_recording failed:",e),self.postMessage({type:"recordingStopped",success:!1,error:`Stop recording failed: ${e}`})}}catch(r){console.error("[Worker] Exception during stopRecording:",r),self.postMessage({type:"recordingStopped",success:!1,error:"Exception: "+(r.message||r.toString())})}}self.addEventListener("error",r=>{if(console.error("[Worker Global Error]:",r.message,r.filename,r.lineno),self.postMessage)try{self.postMessage({type:"error",error:"Worker error: "+r.message})}catch(e){console.error("[Worker Global Error] Could not send error message",e)}}),self.addEventListener("unhandledrejection",r=>{if(console.error("[Worker Global Error] Unhandled Promise Rejection:",r.reason),self.postMessage)try{self.postMessage({type:"error",error:"Worker promise rejection: "+(r.reason.message||r.reason.toString())})}catch(e){console.error("[Worker Global Error] Could not send rejection message",e)}}),console.log("[Worker] Video encoding worker initialized")})();
