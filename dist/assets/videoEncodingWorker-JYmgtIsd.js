(function(){"use strict";let s,c=0,d=!1,w=!1,g=[],W=!1;const A=30;let y=null,m=[];async function D(r){if(console.log("[Worker] Initializing with WASM URL:",r),!r)throw new Error("WASM URL not provided");const e=await import(r);console.log("[Worker] Module factory loaded.");const i={print:t=>console.log("[WASM Print]",t),printErr:t=>console.error("[WASM Error]",t),locateFile:t=>(console.log("[Worker] Locating file:",t),r.replace("lux.js",t)),importMemory:!0};try{s=await e.default(i),console.log("[Worker] Module instance created.")}catch(t){throw console.error("[Worker] Failed to initialize module:",t),new Error(`Module initialization failed: ${t.message}`)}const n=Object.keys(s).filter(t=>typeof s[t]=="function");console.log("[Worker] Module exports:",n);const l=["start_recording","stop_recording","get_recording_data","get_recorded_frame_count","get_recording_state","get_recording_error","is_recording","worker_add_frame"].filter(t=>!(s&&typeof s[t]=="function"));if(l.length===0)console.log("[Worker] Critical recording functions verified.");else throw console.error(`[Worker] Missing required recording functions: [${l.join(", ")}]`),new Error(`Module recording functions missing: ${l.join(", ")}`)}function _(){if(s&&typeof s.get_recording_error=="function")try{const r=s.get_recording_error();return console.log("[Worker] C++ Error Details:",r),r||"No specific error available"}catch(r){return console.error("[Worker Helper] Failed to get C++ error:",r),"Failed to get C++ error: "+(r.message||r)}return"Module or get_recording_error not available"}function E(r,e,i=null){const n={context:r,cppError:e,jsError:i?i.message||i.toString():null,timestamp:new Date().toISOString(),recordingState:d,frameCount:c,queueSize:g.length};console.error("[Worker] Detailed Error Report:",n);const o=`${r}: C++[${e}]${i?` JS[${n.jsError}]`:""}`;return self.postMessage({type:"error",error:o,details:n}),o}async function S(){if(W||g.length===0)return;W=!0;const r=5;try{for(;g.length>0&&d;){const e=g.splice(0,r);for(const i of e){const n=performance.now();try{const o=s.worker_add_frame(i.imageData,i.width,i.height),t=performance.now()-n;if(m.push(t),o){if(c++,c%30===0){const u=m.reduce((p,h)=>p+h,0)/m.length,f=(performance.now()-y)/1e3,a=c/f;console.log(`[Worker] Performance metrics:
                                Frame #${c}
                                Queue size: ${g.length}
                                Avg processing time: ${u.toFixed(2)}ms
                                Total duration: ${f.toFixed(2)}s
                                Actual FPS: ${a.toFixed(2)}
                                Target FPS: 30`),self.postMessage({type:"recordingProgress",frameCount:c,metrics:{avgProcessingTime:u,totalDuration:f,actualFps:a,queueSize:g.length}}),m=[]}}else console.error("[Worker] Failed to add frame"),self.postMessage({type:"error",error:"Failed to add frame"})}catch(o){console.error("[Worker] Error adding frame:",o),self.postMessage({type:"error",error:"Error adding frame: "+o.message})}}await new Promise(i=>setTimeout(i,0))}}finally{W=!1}}self.onmessage=async r=>{const e=r.data;console.log("[Worker] Received message:",e.type);try{switch(e.type){case"init":if(w){console.log("[Worker] Already initialized");return}console.log("[Worker] Initializing..."),await D(e.wasmUrl),w=!0,self.postMessage({type:"initialized"});break;case"startRecording":if(!w)throw new Error("Worker not initialized");d&&(console.log("[Worker] Already recording, stopping first"),await b()),console.log("[Worker] Starting recording with options:",e.options),d=!0,c=0,y=performance.now(),m=[];const i=s.get_buf_width(),n=s.get_buf_height();await s.start_recording(e.options.width,e.options.height,e.options.fps,e.options.bitrate,e.options.codec,e.options.format,e.options.preset)?self.postMessage({type:"recordingStarted",success:!0}):(d=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Failed to start recording"}));break;case"addFrame":if(!s||!s.worker_add_frame||!d){console.warn("[Worker] Ignoring frame - not ready or not recording",{hasModule:!!s,hasAddFrame:!!(s&&s.worker_add_frame),recordingInProgress:d});return}if(!e.imageData||!e.width||!e.height){console.error("[Worker] Invalid frame data:",{hasImageData:!!e.imageData,imageDataLength:e.imageData?e.imageData.length:0,width:e.width,height:e.height,expectedLength:e.width*e.height*4});return}const l=e.width*e.height*4;if(e.imageData.length!==l){console.error("[Worker] Image data length mismatch:",{received:e.imageData.length,expected:l,width:e.width,height:e.height});return}c===0&&console.log("[Worker] Processing first frame:",{width:e.width,height:e.height,dataLength:e.imageData.length,firstPixels:Array.from(e.imageData.slice(0,16)).map(p=>p.toString(16).padStart(2,"0")).join(" ")}),g.push({imageData:e.imageData,width:e.width,height:e.height});const t=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent||"");g.length>=(t?1:A)&&S();break;case"stopRecording":if(!d){console.log("[Worker] Not recording");return}const f=(performance.now()-y)/1e3;console.log(`[Worker] Recording stopped after ${f.toFixed(2)}s with ${c} frames`),console.log(`[Worker] Average FPS: ${(c/f).toFixed(2)}`),d=!1,g.length>0&&await S();const a=await b();self.postMessage({...a,metrics:{totalDuration:f,totalFrames:c,averageFps:c/f}});break;case"getState":if(!s){self.postMessage({type:"recorderState",state:"module_not_ready",frameCount:0,queueSize:0});return}try{const p=typeof s.get_recording_state=="function"?s.get_recording_state():"unknown",h=typeof s.get_recorded_frame_count=="function"?s.get_recorded_frame_count():0,M=typeof s.is_recording=="function"?s.is_recording():!1;self.postMessage({type:"recorderState",state:p,frameCount:h,queueSize:0,isCppRecording:M,isWorkerRecording:d})}catch(p){console.error("[Worker] Exception during getState:",p),self.postMessage({type:"recorderState",state:"error_getting_state",frameCount:0,queueSize:0})}break;default:console.warn("[Worker] Unknown message type:",e.type)}}catch(i){console.error("[Worker] Error:",i),self.postMessage({type:"error",error:i.message})}};async function b(){try{console.log("[Worker] Stopping recording and finalizing..."),d=!1,g.length>0&&(console.log(`[Worker] Processing ${g.length} remaining frames before stopping`),await S());const r=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent||""),e=/iPhone|iPad|iPod/i.test(navigator.userAgent||"");r&&(console.log(`[Worker] Mobile device detected: ${e?"iOS":"Android"}`),await new Promise(o=>setTimeout(o,100)));let i=!1,n=null;try{i=s.stop_recording()}catch(o){if(n=o,console.error("[Worker] Exception calling stop_recording:",o),r)console.log("[Worker] Mobile: Attempting to recover partial data after stop failure"),i=!1;else throw o}if(i||r&&!i){console.log(`[Worker] Recording ${i?"stopped successfully":"stopped with warnings (mobile)"}, getting data`);let o=null,l=null;try{o=s.get_recording_data()}catch(t){if(l=t,console.error("[Worker] Exception getting recording data:",t),r)console.log("[Worker] Mobile: Data retrieval failed, this is expected on some devices");else throw t}if(o&&o.length>0){console.log(`[Worker] Got ${o.length} bytes of video data`);const t=Array.from(o.slice(0,16)).map(k=>k.toString(16).padStart(2,"0")).join(" ");console.log("[Worker] First 16 bytes:",t);const u=r?100:1e3;if(o.length<u){const k=`Video data too small for ${r?"mobile":"desktop"}: ${o.length} bytes (min: ${u})`;if(r)console.warn("[Worker] "+k+" - attempting download anyway");else throw new Error(k)}const f=new ArrayBuffer(o.length),a=new Uint8Array(f);a.set(o);const p=s.get_recorded_frame_count()||0;if(console.log(`[Worker] Final frame count: ${p}`),!(a[0]===26&&a[1]===69&&a[2]===223&&a[3]===163))if(console.error("[Worker] Invalid WebM header. Expected EBML header (1A 45 DF A3)"),console.error("[Worker] Got:",t),r)console.log("[Worker] Mobile: Invalid header detected, attempting to fix..."),a.length>4&&(a[0]=26,a[1]=69,a[2]=223,a[3]=163,console.log("[Worker] Mobile: Header fixed"));else throw new Error("Invalid WebM header on desktop");const M=e?"video/webm":'video/webm; codecs="vp8"';self.postMessage({type:"recordingStopped",success:!0,videoData:a,frameCount:p,mimeType:M,duration:p/30,platform:r?e?"iOS":"Android":"Desktop",warnings:i?[]:["Stop recording had warnings but data recovered"]},[f])}else{console.error("[Worker] No video data returned");const t={platform:r?e?"iOS":"Android":"Desktop",stopSuccess:i,stopError:n?n.message:null,dataError:l?l.message:null,frameCount:c||0,arrayLength:o?o.length:0,cppError:_()};console.error("[Worker] Error details:",t),self.postMessage({type:"recordingStopped",success:!1,error:`No video data available (${t.platform})`,details:t})}}else{const o=_();console.error("[Worker] stop_recording failed:",o);const l={platform:r?e?"iOS":"Android":"Desktop",cppError:o,stopError:n?n.message:null,frameCount:c||0,userAgent:navigator.userAgent||"unknown"},t=E("Stop Recording Failed",o);self.postMessage({type:"recordingStopped",success:!1,error:t,details:l})}}catch(r){console.error("[Worker] Exception during stopRecording:",r);const e=_(),i=/iPhone|iPad|iPod|Android/i.test(navigator.userAgent||""),n=/iPhone|iPad|iPod/i.test(navigator.userAgent||""),o={platform:i?n?"iOS":"Android":"Desktop",exception:r.message||r.toString(),cppError:e,stack:r.stack||"No stack trace",frameCount:c||0};console.error("[Worker] Exception details:",o);const l=E("Stop Recording Exception",e,r);self.postMessage({type:"recordingStopped",success:!1,error:l,details:o})}}self.addEventListener("error",r=>{if(console.error("[Worker Global Error]:",r.message,r.filename,r.lineno),self.postMessage)try{self.postMessage({type:"error",error:"Worker error: "+r.message})}catch(e){console.error("[Worker Global Error] Could not send error message",e)}}),self.addEventListener("unhandledrejection",r=>{if(console.error("[Worker Global Error] Unhandled Promise Rejection:",r.reason),self.postMessage)try{self.postMessage({type:"error",error:"Worker promise rejection: "+(r.reason.message||r.reason.toString())})}catch(e){console.error("[Worker Global Error] Could not send rejection message",e)}}),console.log("[Worker] Video encoding worker initialized")})();
