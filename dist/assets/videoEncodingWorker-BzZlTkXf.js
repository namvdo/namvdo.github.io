(function(){"use strict";let o,i=0,l=!1,m=!1,a=[],h=!1;const M=30;let k=null,p=[];async function F(r){if(console.log("[Worker] Initializing with WASM URL:",r),!r)throw new Error("WASM URL not provided");const e=await import(r);console.log("[Worker] Module factory loaded.");const t={print:n=>console.log("[WASM Print]",n),printErr:n=>console.error("[WASM Error]",n),locateFile:n=>(console.log("[Worker] Locating file:",n),r.replace("lux.js",n)),importMemory:!0};try{o=await e.default(t),console.log("[Worker] Module instance created.")}catch(n){throw console.error("[Worker] Failed to initialize module:",n),new Error(`Module initialization failed: ${n.message}`)}const c=Object.keys(o).filter(n=>typeof o[n]=="function");console.log("[Worker] Module exports:",c);const g=["start_recording","stop_recording","get_recording_data","get_recorded_frame_count","get_recording_state","get_recording_error","is_recording","worker_add_frame"].filter(n=>!(o&&typeof o[n]=="function"));if(g.length===0)console.log("[Worker] Critical recording functions verified.");else throw console.error(`[Worker] Missing required recording functions: [${g.join(", ")}]`),new Error(`Module recording functions missing: ${g.join(", ")}`)}function _(){if(o&&typeof o.get_recording_error=="function")try{const r=o.get_recording_error();return console.log("[Worker] C++ Error Details:",r),r||"No specific error available"}catch(r){return console.error("[Worker Helper] Failed to get C++ error:",r),"Failed to get C++ error: "+(r.message||r)}return"Module or get_recording_error not available"}function w(r,e,t=null){const c={context:r,cppError:e,jsError:t?t.message||t.toString():null,timestamp:new Date().toISOString(),recordingState:l,frameCount:i,queueSize:a.length};console.error("[Worker] Detailed Error Report:",c);const s=`${r}: C++[${e}]${t?` JS[${c.jsError}]`:""}`;return self.postMessage({type:"error",error:s,details:c}),s}async function y(){if(h||a.length===0)return;h=!0;const r=5;try{for(;a.length>0&&l;){const e=a.splice(0,r);for(const t of e){const c=performance.now();try{const s=o.worker_add_frame(t.imageData,t.width,t.height),n=performance.now()-c;if(p.push(n),s){if(i++,i%30===0){const d=p.reduce((W,E)=>W+E,0)/p.length,f=(performance.now()-k)/1e3,u=i/f;console.log(`[Worker] Performance metrics:
                                Frame #${i}
                                Queue size: ${a.length}
                                Avg processing time: ${d.toFixed(2)}ms
                                Total duration: ${f.toFixed(2)}s
                                Actual FPS: ${u.toFixed(2)}
                                Target FPS: 30`),self.postMessage({type:"recordingProgress",frameCount:i,metrics:{avgProcessingTime:d,totalDuration:f,actualFps:u,queueSize:a.length}}),p=[]}}else console.error("[Worker] Failed to add frame"),self.postMessage({type:"error",error:"Failed to add frame"})}catch(s){console.error("[Worker] Error adding frame:",s),self.postMessage({type:"error",error:"Error adding frame: "+s.message})}}await new Promise(t=>setTimeout(t,0))}}finally{h=!1}}self.onmessage=async r=>{const e=r.data;console.log("[Worker] Received message:",e.type);try{switch(e.type){case"init":if(m){console.log("[Worker] Already initialized");return}console.log("[Worker] Initializing..."),await F(e.wasmUrl),m=!0,self.postMessage({type:"initialized"});break;case"startRecording":if(!m)throw new Error("Worker not initialized");l&&(console.log("[Worker] Already recording, stopping first"),await S()),console.log("[Worker] Starting recording with options:",e.options),l=!0,i=0,k=performance.now(),p=[];const t=o.get_buf_width(),c=o.get_buf_height();await o.start_recording(e.options.width,e.options.height,e.options.fps,e.options.bitrate,e.options.codec,e.options.format,e.options.preset)?self.postMessage({type:"recordingStarted",success:!0}):(l=!1,self.postMessage({type:"recordingStarted",success:!1,error:"Failed to start recording"}));break;case"addFrame":if(!o||!o.worker_add_frame||!l){console.warn("[Worker] Ignoring frame - not ready or not recording");return}if(!e.imageData||!e.width||!e.height){console.error("[Worker] Invalid frame data:",{hasImageData:!!e.imageData,width:e.width,height:e.height});return}a.push({imageData:e.imageData,width:e.width,height:e.height}),a.length>=M&&y();break;case"stopRecording":if(!l){console.log("[Worker] Not recording");return}const n=(performance.now()-k)/1e3;console.log(`[Worker] Recording stopped after ${n.toFixed(2)}s with ${i} frames`),console.log(`[Worker] Average FPS: ${(i/n).toFixed(2)}`),l=!1,a.length>0&&await y();const d=await S();self.postMessage({...d,metrics:{totalDuration:n,totalFrames:i,averageFps:i/n}});break;case"getState":if(!o){self.postMessage({type:"recorderState",state:"module_not_ready",frameCount:0,queueSize:0});return}try{const f=typeof o.get_recording_state=="function"?o.get_recording_state():"unknown",u=typeof o.get_recorded_frame_count=="function"?o.get_recorded_frame_count():0,W=typeof o.is_recording=="function"?o.is_recording():!1;self.postMessage({type:"recorderState",state:f,frameCount:u,queueSize:0,isCppRecording:W,isWorkerRecording:l})}catch(f){console.error("[Worker] Exception during getState:",f),self.postMessage({type:"recorderState",state:"error_getting_state",frameCount:0,queueSize:0})}break;default:console.warn("[Worker] Unknown message type:",e.type)}}catch(t){console.error("[Worker] Error:",t),self.postMessage({type:"error",error:t.message})}};async function S(){try{if(console.log("[Worker] Stopping recording and finalizing..."),l=!1,a.length>0&&(console.log(`[Worker] Processing ${a.length} remaining frames before stopping`),await y()),o.stop_recording()){console.log("[Worker] Recording stopped successfully, getting data");const e=o.get_recording_data();if(e&&e.length>0){console.log(`[Worker] Got ${e.length} bytes of video data`);const t=Array.from(e.slice(0,16)).map(d=>d.toString(16).padStart(2,"0")).join(" ");if(console.log("[Worker] First 16 bytes:",t),e.length<1e3)throw new Error("Video data too small, likely corrupted");const c=new ArrayBuffer(e.length),s=new Uint8Array(c);s.set(e);const g=o.get_recorded_frame_count()||0;console.log(`[Worker] Final frame count: ${g}`),s[0]===26&&s[1]===69&&s[2]===223&&s[3]===163||(console.error("[Worker] Invalid WebM header. Expected EBML header (1A 45 DF A3)"),console.error("[Worker] Got:",t),s.length>4&&(console.log("[Worker] Attempting to fix WebM header..."),s[0]=26,s[1]=69,s[2]=223,s[3]=163,console.log("[Worker] Header fixed, new header:",Array.from(s.slice(0,4)).map(d=>d.toString(16).padStart(2,"0")).join(" ")))),self.postMessage({type:"recordingStopped",success:!0,videoData:s,frameCount:g,mimeType:'video/webm; codecs="vp8"',duration:g/30},[c])}else console.error("[Worker] No video data returned"),self.postMessage({type:"recordingStopped",success:!1,error:"No video data available"})}else{const e=_();console.error("[Worker] stop_recording failed:",e);const t=w("Stop Recording Failed",e);self.postMessage({type:"recordingStopped",success:!1,error:t})}}catch(r){console.error("[Worker] Exception during stopRecording:",r);const e=_(),t=w("Stop Recording Exception",e,r);self.postMessage({type:"recordingStopped",success:!1,error:t})}}self.addEventListener("error",r=>{if(console.error("[Worker Global Error]:",r.message,r.filename,r.lineno),self.postMessage)try{self.postMessage({type:"error",error:"Worker error: "+r.message})}catch(e){console.error("[Worker Global Error] Could not send error message",e)}}),self.addEventListener("unhandledrejection",r=>{if(console.error("[Worker Global Error] Unhandled Promise Rejection:",r.reason),self.postMessage)try{self.postMessage({type:"error",error:"Worker promise rejection: "+(r.reason.message||r.reason.toString())})}catch(e){console.error("[Worker Global Error] Could not send rejection message",e)}}),console.log("[Worker] Video encoding worker initialized")})();
